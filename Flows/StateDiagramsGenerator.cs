using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using NLog;

namespace Flows
{
    public class StateDiagramsGenerator
    {
        private static readonly ILogger Log = LogManager.GetCurrentClassLogger();

        private Dictionary<string, string> States = new Dictionary<string, string>();
        private Dictionary<string, Dictionary<string, bool>> Producers = new Dictionary<string, Dictionary<string, bool>>();
        private Dictionary<string, Dictionary<string, bool>> Consumers = new Dictionary<string, Dictionary<string, bool>>();

        private Dictionary<string, (Dictionary<string, bool> Consumes, Dictionary<string, bool> Produces)> Nodes = 
            new Dictionary<string, (Dictionary<string, bool> Consumes, Dictionary<string, bool> Produces)>();
        private List<(string producer, string fact, string consumer)> Relations = new List<(string, string, string)>();

        public string GetPumlCodeFullText()
        {
            var sb = new StringBuilder();

            sb.AppendLine(@"/'Generated by flows.exe parse'/ [hmk]\n");
            sb.AppendLine(@"@startuml\n");
            
            foreach (var state in States)
            {
                sb.AppendLine($@"state {state.Key} {{");
                sb.AppendLine(@"}");
            }

            foreach (var relation in Relations)
            {
                sb.AppendLine($"{relation.producer} --> {relation.consumer} : {relation.fact}");

                if(Producers.TryGetValue(relation.producer, out var producerFactMap))
                {
                    if (producerFactMap.ContainsKey(relation.fact))
                    {
                        producerFactMap[relation.fact] = true;
                    }
                    else
                    {
                        Log.Warn($"Undefined Fact [{relation.fact}] for producer [{relation.producer}]");
                    }
                }
                else
                {
                    Log.Warn($"Producer [{relation.producer}] not found in defined States");
                }
            }

            sb.AppendLine($"/'Events with no consumers'/");
            foreach (var producer in Producers)
            {
                foreach (var notConsumedFact in producer.Value.Where(factMap => factMap.Value != true).Select(factMap => factMap.Key))
                {
                    sb.AppendLine($"{producer.Key} --> __WhoConsumes_{notConsumedFact} : {notConsumedFact}");
                }
            }

            sb.AppendLine($"/' Events with no producers '/");
            foreach (var consumer in Consumers)
            {
                foreach (var notProducedFact in consumer.Value.Where(factMap => factMap.Value != true))
                {
                    sb.AppendLine($"__WhoProduce_{notProducedFact} --> {consumer.Key} : {notProducedFact}");
                }
            }

            sb.AppendLine(@"@enduml");

            return sb.ToString();
        }

        public string GetPumlCodeFullTextNodesVersion(bool includeActionFlow = false)
        {
            // scan relation first
            foreach (var relation in Relations)
            {
                if (Nodes.TryGetValue(relation.producer, out var produceConsumeTuple))
                {
                    if (produceConsumeTuple.Produces.ContainsKey(relation.fact))
                    {
                        produceConsumeTuple.Produces[relation.fact] = true;
                    }
                }
                
                if (Nodes.TryGetValue(relation.consumer, out var produceConsumeAnotherTuple))
                {
                    if (produceConsumeAnotherTuple.Consumes.ContainsKey(relation.fact))
                    {
                        produceConsumeAnotherTuple.Consumes[relation.fact] = true;
                    }
                }
            }

            var sb = new StringBuilder();

            sb.AppendLine("/'Generated by flows.exe parse [hmk]'/\n");
            sb.AppendLine("@startuml\n");

            foreach (var node in Nodes)
            {
                sb.AppendLine($@"state {node.Key} {{");

                var notConsumedFacts = node.Value.Produces.Where(eventUsed => eventUsed.Value == false).Select(eventUsed => eventUsed.Key).ToList();
                var notProvidedFacts = node.Value.Consumes.Where(eventUsed => eventUsed.Value == false).Select(eventUsed => eventUsed.Key).ToList();

                if (notProvidedFacts.Any())
                {
                    sb.AppendLine($"\t{node.Key} : notProvided:");
                    notProvidedFacts.ForEach(fact => sb.AppendLine($"\t{node.Key} : {fact}"));
                }

                if (notConsumedFacts.Any())
                {
                    sb.AppendLine($"\t{node.Key} : notConsumed:");
                    notConsumedFacts.ForEach(fact => sb.AppendLine($"\t{node.Key} : {fact}"));
                }

                sb.AppendLine(@"}");
            }

            foreach (var relation in Relations)
            {
                sb.AppendLine($"{relation.producer} --> {relation.consumer} : {relation.fact}");

                if (Nodes.TryGetValue(relation.producer, out var produceConsumeTuple))
                {
                    if (produceConsumeTuple.Produces.ContainsKey(relation.fact))
                    {
                        produceConsumeTuple.Produces[relation.fact] = true;
                    }
                    else
                    {
                        Log.Warn($"Undefined Fact [{relation.fact}] for producer [{relation.producer}]");
                    }
                }
                else
                {
                    Log.Warn($"[{relation.producer}] not found in defined Nodes");
                }

                if (Nodes.TryGetValue(relation.consumer, out var produceConsumeAnotherTuple))
                {
                    if (produceConsumeAnotherTuple.Consumes.ContainsKey(relation.fact))
                    {
                        produceConsumeAnotherTuple.Consumes[relation.fact] = true;
                    }
                    else
                    {
                        Log.Warn($"Undefined Fact [{relation.fact}] for producer [{relation.producer}]");
                    }
                }
                else
                {
                    Log.Warn($"[{relation.producer}] not found in defined Nodes");
                }
            }

            sb.AppendLine(@"@enduml");

            return sb.ToString();
        }

        public void ParseForMnemonics(StreamReader text)
        {
            while (!text.EndOfStream)
            {
                var line = text.ReadLine();
                if (line != null)
                {
                    if (line.Contains(ExtraLogParserMarkers.EventParticipationLogStart))
                    {
                        Log.Info($"Found! event sourcing configuration dependency");
                    }

                    if (line.Contains(ExtraLogParserMarkers.EventParticipationLogEntry))
                    {
                        Log.Info($"States: {line}");

                        var pos = line.IndexOf(ExtraLogParserMarkers.EventParticipationLogEntry, StringComparison.Ordinal);
                        var length = line.Length;
                        var rest = line.Substring(pos + 32, length - pos - 32);

                        var mnemonic_split = rest.Split(':');

                        var foundState = mnemonic_split.First().NormalizeMnemonic();

                        States.TryAdd(foundState, foundState);
                        Nodes.TryAdd(foundState, (new Dictionary<string, bool>(), new Dictionary<string, bool>()));
                    }

                    if (line.Contains(ExtraLogParserMarkers.EventParticipationEventFlowLogEntry))
                    {
                        Log.Info($"Arrows: {line}");

                        var pos = line.IndexOf(ExtraLogParserMarkers.EventParticipationEventFlowLogEntry, StringComparison.Ordinal);
                        var length = line.Length;
                        var rest = line.Substring(pos + 26, length - pos - 26);


                        var leftAndRightParts = rest.Split('-');

                        var producerParts = leftAndRightParts[0].Trim().Split(':');
                        var consumersParts = leftAndRightParts[1].Remove(0, 1).Trim().Split(':');

                        var producerName = producerParts[0].NormalizeMnemonic();
                        var producedEvent = producerParts[1].NormalizeMnemonic();

                        Producers.TryAdd(producerName, new Dictionary<string, bool>());
                        Producers[producerName].TryAdd(producedEvent, false);

                        Nodes[producerName].Produces.TryAdd(producedEvent, false);

                        var consumerName = consumersParts[0].NormalizeMnemonic();

                        Consumers.TryAdd(consumerName, new Dictionary<string, bool>());
                        Nodes[consumerName].Consumes.TryAdd(producedEvent, false);
                        foreach (var consumerNextEvents in consumersParts[1].NormalizeMnemonic().Split(','))
                        {
                            if(consumerNextEvents.Equals("NONE"))
                                continue;

                            Consumers[consumerName].TryAdd(consumerNextEvents.Trim(), false);

                            Nodes[consumerName].Produces.TryAdd(consumerNextEvents, false);
                        }

                        Relations.Add((producerName, producedEvent, consumerName));

                    }

                    if (line.Contains(ExtraLogParserMarkers.HackyEndOfParsingMarker))
                    {
                        Log.Info($"42?");
                    }
                }
            }
        }
    }

    public static class ParserExtensions
    {
        public static string NormalizeMnemonic(this string text)
        {
            return text.Trim().Replace(" ", "_");
        }
    }
}